# データベースにおける MMAP

最近 Twitter で以下の論文の存在を知って、少し興味があったので、読んでみた[^1]。

[^1]: 論文のヘッダに "MMAP = :poop" とかあって、既存技術をディスる系なのはちょっと好きではないけど。

- ["Are You Sure You Want to Use MMAP in Your Database Management System?"](https://cs.brown.edu/people/acrotty/pubs/p13-crotty.pdf)

結論としては「DBMS で mmap を使ってよいのはデータベースのサイズがメモリに収まって、かつリードオンリーな場合」で、ごく限られた状況だけで実質使うなと言っているが、まあそれは身も蓋もなく筆者の意見と思うとして、根拠の部分には興味がある。

File I/O (read/write システムコール) の代わりに mmap を使う利点としては、システムコールのオーバーヘッドを回避できるというのと、I/O の細かい制御を OS に任せることで DBMS をシンプルに実装できる、など言われているが。

# 課題

DBMS で mmap を使う際に問題となる点として以下 4 つあげている。

- トランザクションの安全性
- I/O ストール (async I/O できない)
- エラーハンドリング
- 性能上の問題

3 つめまでは DBMS の実装を工夫すれば対処できるようだが、深刻なのは最後の性能問題のようだ。
mmap の利点としてはシステムコールオーバーヘッドの回避と、メモリコピーが不要な点があるが、

ストレージの高速化により顕在化した問題として OS のページ回収アルゴリズムは数スレッドを越えてスケールしないらしい。
これは kswapd がシングルスレッドだから

さらにページテーブルを同期しないといけないが、同時実行するスレッドが増えると競合が激しくなることも性能問題の要因に上げているが、あまり論文内で説明されておらず、よく分からないね。

で、この二つはカーネルに手を加えることで対処可能としているが、mmap を使用すると不可避な問題なのが TLB shootdown だと言っている。
TLB shootdown の問題は mmap を使っている以上は不可避で、どうしようもないようだ。

TLB shootdown 処理はページ回収の際に、他の CPU コアの TLB にある当該ページへのエントリを削除するという処理で、結構重い処理 (数千サイクル) であるため、パフォーマンスへの影響が大きい。

# 感想・疑問

高性能やスケーラビリティを気にしなくていい状況では mmap で面倒ごとを OS に丸投げしてもよいが、大規模・堅牢なシステムで動くアプリケーションは自前で頑張るべき、というのは妥当で、結論自体は意外ではないが、少し詳細な問題点を知ることができたのはプラスだったかなと思う。

感想としては、実験があっさりしすぎで、これで課題を全て浮き彫りにして議論したとはちょっと思いにくい部分がるある。
また、ページテーブル同期の競合とか、あまり議論・実験されていない点もあって、もう少しボリュームが欲しいなという気がした。

システムコールオーバーヘッドや I/O ストールの問題については io_uring などで回避できるようになってくると思うし、mmap で管理が楽になるというのも、メモリ管理の粒度や IO スケジューリングの管理ができないなど落としてはいけないものまで落ちてしまっているので、mmap は普通に機能不足なのではないかな。

カーネルの MM コミュニティで活動している身としては、最近のメモリ管理の制御の発展がデータベース側に必要とされる機能を提供できるようになれば、また mmap の利用価値が見直されてくるのではないかとも思うが、コミュニティ間の連携や新機能の登場が待たれる気がしていて、長期的な期待になりそうに思う。

thp が例外なくオフられる問題はこの話の一部としてあり、個人的に何が満たされれば DBMS のようなアプリケーションがうまくカーネルの機能を使えるのか、というのは知っておきたい気がする。


mmap は非効率だ、それは分かった。
個人的に気になるのは hugetlbfs を用いるデータベースである。
これらはバッキングストアがない (swap out もしない) ため、メモリ回収を前提としない用途で用いる前提である。
なので、データベースが hugetlbfs を用いる場合、どういう使い方をするのかというと、
メモリサイズを意識して従来どおりデータベース側でデータの書き出し、削除をコントロールしないといけないということになる。
おそらく通常のメモリの使い方とは異なる使い方をしているところに hugetlbfs を用いているという使い方にならざるを得ないのだろう。
